This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2024-10-31T12:53:40.718Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
.gitignore
data/categories.json
data/templates.json
package.json
src/controllers/categoryController.ts
src/controllers/templateController.ts
src/index.ts
src/models/types.ts
src/public/index.html
src/public/manager.html
src/routes/categoryRoutes.ts
src/routes/templateRoutes.ts
src/services/messageAnalyzer.ts
src/services/storageService.ts
src/utils/keywords.ts
tsconfig.json

================================================================
Repository Files
================================================================

================
File: .gitignore
================
node_modules/

================
File: data/categories.json
================
[]

================
File: data/templates.json
================
[]

================
File: package.json
================
{
  "name": "message-template-system",
  "version": "1.0.0",
  "description": "Sistema de templates de mensagens",
  "main": "dist/index.js",
  "scripts": {
    "start": "node dist/index.js",
    "dev": "nodemon --watch 'src/**/*.ts' --exec ts-node src/index.ts",
    "build": "tsc",
    "test": "echo \"No test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "express": "^4.17.1",
    "message-template-system": "file:"
  },
  "devDependencies": {
    "@types/express": "^4.17.17",
    "@types/node": "^18.15.11",
    "nodemon": "^2.0.22",
    "ts-node": "^10.9.1",
    "typescript": "^5.0.4"
  }
}

================
File: src/controllers/categoryController.ts
================
// src/controllers/categoryController.ts

import { Request, Response, NextFunction } from 'express';
import { CreateCategoryDTO, UpdateCategoryDTO } from '../models/types';
import storageService from '../services/storageService';

class CategoryController {
    /**
     * GET /api/categories
     * Retorna todas as categorias
     */
    public async getAllCategories(req: Request, res: Response, next: NextFunction) {
        try {
            const categories = await storageService.getCategories();
            res.json(categories);
        } catch (error) {
            next(error);
        }
    }

    /**
     * GET /api/categories/:id
     * Retorna uma categoria específica por ID
     */
    public async getCategory(req: Request, res: Response, next: NextFunction) {
        try {
            const { id } = req.params;
            const category = await storageService.getCategory(id);
            
            if (!category) {
                return res.status(404).json({ 
                    error: 'Categoria não encontrada',
                    details: `Não foi possível encontrar uma categoria com o ID: ${id}`
                });
            }
            
            res.json(category);
        } catch (error) {
            next(error);
        }
    }

    /**
     * POST /api/categories
     * Cria uma nova categoria
     */
    public async createCategory(req: Request, res: Response, next: NextFunction) {
        try {
            const { name, keywords, weight } = req.body as CreateCategoryDTO;

            // Validação dos dados
            if (!name?.trim()) {
                return res.status(400).json({
                    error: 'Nome inválido',
                    details: 'O nome da categoria é obrigatório'
                });
            }

            if (!Array.isArray(keywords) || keywords.length === 0) {
                return res.status(400).json({
                    error: 'Keywords inválidas',
                    details: 'É necessário fornecer ao menos uma palavra-chave'
                });
            }

            // Processar keywords
            const processedKeywords = keywords
                .map(k => k.trim())
                .filter(k => k.length > 0);

            if (processedKeywords.length === 0) {
                return res.status(400).json({
                    error: 'Keywords inválidas',
                    details: 'Nenhuma palavra-chave válida fornecida'
                });
            }

            // Validar peso
            const weightNum = Number(weight);
            if (isNaN(weightNum) || weightNum < 0.5 || weightNum > 5) {
                return res.status(400).json({
                    error: 'Peso inválido',
                    details: 'O peso deve ser um número entre 0.5 e 5'
                });
            }

            const newCategory = await storageService.createCategory({
                name: name.trim(),
                keywords: processedKeywords,
                weight: weightNum
            });

            res.status(201).json(newCategory);
        } catch (error) {
            next(error);
        }
    }

    /**
     * PUT /api/categories/:id
     * Atualiza uma categoria existente
     */
    public async updateCategory(req: Request, res: Response, next: NextFunction) {
        try {
            const { id } = req.params;
            const updateData = req.body as UpdateCategoryDTO;
            
            // Validações dos dados de atualização
            if (updateData.name !== undefined) {
                if (!updateData.name.trim()) {
                    return res.status(400).json({
                        error: 'Nome inválido',
                        details: 'O nome da categoria não pode estar vazio'
                    });
                }
                updateData.name = updateData.name.trim();
            }

            if (updateData.keywords !== undefined) {
                if (!Array.isArray(updateData.keywords) || updateData.keywords.length === 0) {
                    return res.status(400).json({
                        error: 'Keywords inválidas',
                        details: 'É necessário fornecer ao menos uma palavra-chave'
                    });
                }

                const processedKeywords = updateData.keywords
                    .map(k => k.trim())
                    .filter(k => k.length > 0);

                if (processedKeywords.length === 0) {
                    return res.status(400).json({
                        error: 'Keywords inválidas',
                        details: 'Nenhuma palavra-chave válida fornecida'
                    });
                }

                updateData.keywords = processedKeywords;
            }

            if (updateData.weight !== undefined) {
                const weightNum = Number(updateData.weight);
                if (isNaN(weightNum) || weightNum < 0.5 || weightNum > 5) {
                    return res.status(400).json({
                        error: 'Peso inválido',
                        details: 'O peso deve ser um número entre 0.5 e 5'
                    });
                }
                updateData.weight = weightNum;
            }

            const updatedCategory = await storageService.updateCategory(id, updateData);

            if (!updatedCategory) {
                return res.status(404).json({ 
                    error: 'Categoria não encontrada',
                    details: `Não foi possível encontrar uma categoria com o ID: ${id}`
                });
            }

            res.json(updatedCategory);
        } catch (error) {
            next(error);
        }
    }

    /**
     * DELETE /api/categories/:id
     * Remove uma categoria e seus templates associados
     */
    public async deleteCategory(req: Request, res: Response, next: NextFunction) {
        try {
            const { id } = req.params;
            const deleted = await storageService.deleteCategory(id);

            if (!deleted) {
                return res.status(404).json({ 
                    error: 'Categoria não encontrada',
                    details: `Não foi possível encontrar uma categoria com o ID: ${id}`
                });
            }

            res.json({ 
                message: 'Categoria deletada com sucesso',
                details: 'A categoria e todos os templates associados foram removidos'
            });
        } catch (error) {
            next(error);
        }
    }
}

export default new CategoryController();

================
File: src/controllers/templateController.ts
================
// src/controllers/templateController.ts

import { Request, Response, NextFunction } from 'express';
import { CreateTemplateDTO, UpdateTemplateDTO } from '../models/types';
import storageService from '../services/storageService';

class TemplateController {
    /**
     * GET /api/templates
     * Retorna todos os templates ou filtrados por categoria
     */
    public async getAllTemplates(req: Request, res: Response, next: NextFunction) {
        try {
            const { categoryId } = req.query;
            
            if (categoryId && typeof categoryId === 'string') {
                // Verificar se a categoria existe
                const category = await storageService.getCategory(categoryId);
                if (!category) {
                    return res.status(404).json({
                        error: 'Categoria não encontrada',
                        details: `Não existe uma categoria com o ID: ${categoryId}`
                    });
                }

                const templates = await storageService.getTemplatesByCategory(categoryId);
                return res.json(templates);
            }

            const templates = await storageService.getTemplates();
            res.json(templates);
        } catch (error) {
            next(error);
        }
    }

    /**
     * GET /api/templates/:id
     * Retorna um template específico por ID
     */
    public async getTemplate(req: Request, res: Response, next: NextFunction) {
        try {
            const { id } = req.params;
            const template = await storageService.getTemplate(id);
            
            if (!template) {
                return res.status(404).json({ 
                    error: 'Template não encontrado',
                    details: `Não foi possível encontrar um template com o ID: ${id}`
                });
            }
            
            res.json(template);
        } catch (error) {
            next(error);
        }
    }

    /**
     * POST /api/templates
     * Cria um novo template
     */
    public async createTemplate(req: Request, res: Response, next: NextFunction) {
        try {
            const { categoryId, text } = req.body as CreateTemplateDTO;

            // Validação dos dados
            if (!categoryId?.trim()) {
                return res.status(400).json({
                    error: 'ID da categoria inválido',
                    details: 'É necessário especificar uma categoria'
                });
            }

            // Verificar se a categoria existe
            const category = await storageService.getCategory(categoryId);
            if (!category) {
                return res.status(400).json({
                    error: 'Categoria não encontrada',
                    details: `Não existe uma categoria com o ID: ${categoryId}`
                });
            }

            if (!text?.trim()) {
                return res.status(400).json({
                    error: 'Texto inválido',
                    details: 'O texto do template não pode estar vazio'
                });
            }

            const newTemplate = await storageService.createTemplate({
                categoryId: categoryId.trim(),
                text: text.trim()
            });

            res.status(201).json(newTemplate);
        } catch (error) {
            next(error);
        }
    }

    /**
     * PUT /api/templates/:id
     * Atualiza um template existente
     */
    public async updateTemplate(req: Request, res: Response, next: NextFunction) {
        try {
            const { id } = req.params;
            const updateData = req.body as UpdateTemplateDTO;
            
            // Validação dos dados de atualização
            if (updateData.categoryId !== undefined) {
                if (!updateData.categoryId.trim()) {
                    return res.status(400).json({
                        error: 'ID da categoria inválido',
                        details: 'É necessário especificar uma categoria'
                    });
                }

                // Verificar se a nova categoria existe
                const category = await storageService.getCategory(updateData.categoryId);
                if (!category) {
                    return res.status(400).json({
                        error: 'Categoria não encontrada',
                        details: `Não existe uma categoria com o ID: ${updateData.categoryId}`
                    });
                }

                updateData.categoryId = updateData.categoryId.trim();
            }

            if (updateData.text !== undefined) {
                if (!updateData.text.trim()) {
                    return res.status(400).json({
                        error: 'Texto inválido',
                        details: 'O texto do template não pode estar vazio'
                    });
                }
                updateData.text = updateData.text.trim();
            }

            const updatedTemplate = await storageService.updateTemplate(id, updateData);

            if (!updatedTemplate) {
                return res.status(404).json({ 
                    error: 'Template não encontrado',
                    details: `Não foi possível encontrar um template com o ID: ${id}`
                });
            }

            res.json(updatedTemplate);
        } catch (error) {
            next(error);
        }
    }

    /**
     * DELETE /api/templates/:id
     * Remove um template
     */
    public async deleteTemplate(req: Request, res: Response, next: NextFunction) {
        try {
            const { id } = req.params;
            const deleted = await storageService.deleteTemplate(id);

            if (!deleted) {
                return res.status(404).json({ 
                    error: 'Template não encontrado',
                    details: `Não foi possível encontrar um template com o ID: ${id}`
                });
            }

            res.json({ 
                message: 'Template deletado com sucesso'
            });
        } catch (error) {
            next(error);
        }
    }

    /**
     * GET /api/templates/category/:categoryId
     * Retorna todos os templates de uma categoria específica
     */
    public async getTemplatesByCategory(req: Request, res: Response, next: NextFunction) {
        try {
            const { categoryId } = req.params;

            // Verificar se a categoria existe
            const category = await storageService.getCategory(categoryId);
            if (!category) {
                return res.status(404).json({
                    error: 'Categoria não encontrada',
                    details: `Não existe uma categoria com o ID: ${categoryId}`
                });
            }

            const templates = await storageService.getTemplatesByCategory(categoryId);
            res.json(templates);
        } catch (error) {
            next(error);
        }
    }
}

export default new TemplateController();

================
File: src/index.ts
================
import express, { Request, Response, NextFunction } from 'express';
import path from 'path';
import { MessageAnalyzer } from './services/messageAnalyzer';
import categoryRoutes from './routes/categoryRoutes';
import templateRoutes from './routes/templateRoutes';

const app = express();
const PORT = process.env.PORT || 3000;
const messageAnalyzer = new MessageAnalyzer();

// Middleware para processar JSON
app.use(express.json());
app.use(express.urlencoded({ extended: true }));
app.use(express.static(path.join(__dirname, 'public')));


app.use('/api/categories', categoryRoutes);
app.use('/api/templates', templateRoutes);

// Rota de teste
app.get('/api/test', (req: Request, res: Response, next: NextFunction) => {
    try {
        res.json({ message: 'API funcionando!' });
    } catch (error) {
        next(error);
    }
});

app.get('/manager', (req, res) => {
    res.sendFile(path.join(__dirname, 'public/manager.html'));
});

// Rota para análise de mensagem
app.post('/api/analyze', async (req: Request, res: Response, next: NextFunction) => {
    try {
        const { message } = req.body;
        if (!message) {
            return res.status(400).json({ error: 'Mensagem não fornecida' });
        }
        const analysis = await messageAnalyzer.analyzeMessage(message);
        res.json({ original: message, analysis });
    } catch (error) {
        next(error);
    }
});

// Error handling middleware
app.use((err: Error, req: Request, res: Response, next: NextFunction) => {
    console.error(err.stack);
    res.status(500).json({
        error: 'Algo deu errado!',
        message: err.message
    });
});

// Iniciar o servidor
app.listen(PORT, () => {
    console.log(`Servidor está rodando na porta: ${PORT}`);
});

export default app;

================
File: src/models/types.ts
================
export interface Category {
    id: string;
    name: string;
    keywords: string[];
    weight: number;
    createdAt: Date;
    updatedAt: Date;
}

export interface Template {
    id: string;
    categoryId: string;
    text: string;
    createdAt: Date;
    updatedAt: Date;
}

================
File: src/public/index.html
================
<!-- src/public/index.html -->
<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Análise de Mensagens - Template Matcher</title>
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- Font Awesome -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        .suggestion-card {
            transition: transform 0.2s ease;
        }
        .suggestion-card:hover {
            transform: translateY(-2px);
            cursor: pointer;
        }
        .confidence-high { background-color: #d4edda; }
        .confidence-medium { background-color: #fff3cd; }
        .confidence-low { background-color: #f8d7da; }
        .loading-spinner {
            display: none;
        }
        .category-badge {
            font-size: 0.85em;
        }
    </style>
</head>
<body>
    <!-- Navbar -->
    <nav class="navbar navbar-expand-lg navbar-dark bg-primary">
        <div class="container">
            <a class="navbar-brand" href="/">Template Matcher</a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav">
                    <li class="nav-item">
                        <a class="nav-link active" href="/">Analisador</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/manager">Gerenciador</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <!-- Main Content -->
    <div class="container my-4">
        <div class="row">
            <!-- Input Section -->
            <div class="col-md-6">
                <div class="card">
                    <div class="card-header bg-primary text-white">
                        <h5 class="mb-0">
                            <i class="fas fa-comment-alt me-2"></i>
                            Mensagem do Cliente
                        </h5>
                    </div>
                    <div class="card-body">
                        <form id="analysisForm" onsubmit="analyzeMessage(event)">
                            <div class="mb-3">
                                <textarea 
                                    class="form-control" 
                                    id="messageInput" 
                                    rows="6"
                                    placeholder="Digite aqui a mensagem do cliente..."
                                    required></textarea>
                            </div>
                            <button type="submit" class="btn btn-primary">
                                <i class="fas fa-search me-2"></i>
                                Analisar Mensagem
                                <div class="spinner-border spinner-border-sm loading-spinner" role="status">
                                    <span class="visually-hidden">Carregando...</span>
                                </div>
                            </button>
                            <button type="button" class="btn btn-outline-secondary" onclick="clearForm()">
                                <i class="fas fa-eraser me-2"></i>
                                Limpar
                            </button>
                        </form>
                    </div>
                </div>
            </div>

            <!-- Results Section -->
            <div class="col-md-6">
                <div class="card">
                    <div class="card-header bg-primary text-white">
                        <h5 class="mb-0">
                            <i class="fas fa-chart-pie me-2"></i>
                            Resultados da Análise
                        </h5>
                    </div>
                    <div class="card-body">
                        <!-- Categories Analysis -->
                        <div id="categoriesSection" style="display: none;">
                            <h6 class="card-subtitle mb-2 text-muted">
                                <i class="fas fa-tags me-2"></i>
                                Categorias Identificadas
                            </h6>
                            <div id="categoriesList" class="mb-4">
                                <!-- Categories will be inserted here -->
                            </div>
                        </div>

                        <!-- Templates Suggestions -->
                        <div id="suggestionsSection" style="display: none;">
                            <h6 class="card-subtitle mb-2 text-muted">
                                <i class="fas fa-lightbulb me-2"></i>
                                Templates Sugeridos
                            </h6>
                            <div id="suggestionsList">
                                <!-- Suggestions will be inserted here -->
                            </div>
                        </div>

                        <!-- Initial State Message -->
                        <div id="initialMessage" class="text-center text-muted py-4">
                            <i class="fas fa-search fa-3x mb-3"></i>
                            <p>Digite uma mensagem e clique em "Analisar" para receber sugestões de templates.</p>
                        </div>

                        <!-- Loading State -->
                        <div id="loadingMessage" class="text-center py-4" style="display: none;">
                            <div class="spinner-border text-primary mb-3" role="status">
                                <span class="visually-hidden">Carregando...</span>
                            </div>
                            <p class="text-muted">Analisando mensagem...</p>
                        </div>

                        <!-- No Results Message -->
                        <div id="noResultsMessage" class="text-center text-muted py-4" style="display: none;">
                            <i class="fas fa-exclamation-circle fa-3x mb-3"></i>
                            <p>Nenhum template sugerido encontrado para esta mensagem.</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Toast container for notifications -->
    <div class="toast-container position-fixed bottom-0 end-0 p-3"></div>

    <!-- Scripts -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        // Estado global da aplicação
        let currentAnalysis = null;

        // Função para analisar a mensagem
        async function analyzeMessage(event) {
            event.preventDefault();
            const messageInput = document.getElementById('messageInput');
            const message = messageInput.value.trim();
            
            setLoadingState(true);
            
            try {
                const response = await fetch('/api/analyze', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ message })
                });
                
                const data = await response.json();
                
                if (!response.ok) {
                    throw new Error(data.error || 'Erro ao analisar mensagem');
                }

                currentAnalysis = data;
                displayResults(data);
                
            } catch (error) {
                showToast('Erro', error.message, 'danger');
            } finally {
                setLoadingState(false);
            }
        }

        // Função para exibir os resultados
        function displayResults(data) {
            const { analysis } = data;
            
            // Mostrar seção de categorias
            displayCategories(analysis.categories, analysis.confidence);
            
            // Mostrar seção de sugestões
            displaySuggestions(analysis.suggestedTemplates);
            
            // Atualizar visibilidade das seções
            document.getElementById('initialMessage').style.display = 'none';
            document.getElementById('categoriesSection').style.display = 'block';
            document.getElementById('suggestionsSection').style.display = 'block';
            
            if (analysis.suggestedTemplates.length === 0) {
                document.getElementById('noResultsMessage').style.display = 'block';
                document.getElementById('suggestionsList').style.display = 'none';
            } else {
                document.getElementById('noResultsMessage').style.display = 'none';
                document.getElementById('suggestionsList').style.display = 'block';
            }
        }

        // Função para exibir categorias
        function displayCategories(categories, confidence) {
            const categoriesList = document.getElementById('categoriesList');
            const sortedCategories = Object.entries(categories)
                .sort(([,a], [,b]) => b - a);
            
            const html = sortedCategories.map(([category, score]) => {
                const percentage = (score * 100).toFixed(1);
                const confidenceClass = score > 0.7 ? 'bg-success' : 
                                    score > 0.4 ? 'bg-warning' : 'bg-danger';
                
                return `
                    <div class="d-flex justify-content-between align-items-center mb-2">
                        <span class="category-name">${category}</span>
                        <span class="badge ${confidenceClass} category-badge">
                            ${percentage}%
                        </span>
                    </div>
                `;
            }).join('');
            
            categoriesList.innerHTML = html;
        }

        // Função para exibir sugestões
        function displaySuggestions(templates) {
            const suggestionsList = document.getElementById('suggestionsList');
            
            const html = templates.map((template, index) => `
                <div class="card mb-3 suggestion-card" onclick="copyTemplate(${index})">
                    <div class="card-body">
                        <div class="d-flex justify-content-between">
                            <p class="card-text mb-0">${template}</p>
                            <button class="btn btn-sm btn-outline-primary ms-2" 
                                    onclick="event.stopPropagation(); copyTemplate(${index})">
                                <i class="fas fa-copy"></i>
                            </button>
                        </div>
                    </div>
                </div>
            `).join('');
            
            suggestionsList.innerHTML = html;
        }

        // Função para copiar template
        async function copyTemplate(index) {
            const template = currentAnalysis.analysis.suggestedTemplates[index];
            try {
                await navigator.clipboard.writeText(template);
                showToast('Sucesso', 'Template copiado para a área de transferência!', 'success');
            } catch (err) {
                showToast('Erro', 'Não foi possível copiar o template', 'danger');
            }
        }

        // Função para limpar o formulário
        function clearForm() {
            document.getElementById('messageInput').value = '';
            document.getElementById('initialMessage').style.display = 'block';
            document.getElementById('categoriesSection').style.display = 'none';
            document.getElementById('suggestionsSection').style.display = 'none';
            document.getElementById('noResultsMessage').style.display = 'none';
            currentAnalysis = null;
        }

        // Função para controlar estado de carregamento
        function setLoadingState(loading) {
            const submitButton = document.querySelector('button[type="submit"]');
            const loadingSpinner = submitButton.querySelector('.loading-spinner');
            const initialMessage = document.getElementById('initialMessage');
            const loadingMessage = document.getElementById('loadingMessage');
            
            submitButton.disabled = loading;
            loadingSpinner.style.display = loading ? 'inline-block' : 'none';
            
            if (loading) {
                initialMessage.style.display = 'none';
                loadingMessage.style.display = 'block';
            } else {
                loadingMessage.style.display = 'none';
            }
        }

        // Função para exibir toasts
        function showToast(title, message, type = 'info') {
            const toastContainer = document.querySelector('.toast-container');
            const toastHtml = `
                <div class="toast align-items-center text-white bg-${type} border-0" role="alert" aria-live="assertive" aria-atomic="true">
                    <div class="d-flex">
                        <div class="toast-body">
                            <strong>${title}</strong><br>
                            ${message}
                        </div>
                        <button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast"></button>
                    </div>
                </div>
            `;
            
            toastContainer.insertAdjacentHTML('beforeend', toastHtml);
            const toast = toastContainer.lastElementChild;
            const bsToast = new bootstrap.Toast(toast, { autohide: true, delay: 3000 });
            
            toast.addEventListener('hidden.bs.toast', () => {
                toast.remove();
            });
            
            bsToast.show();
        }
    </script>
</body>
</html>

================
File: src/public/manager.html
================
<!-- src/public/manager.html -->
<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gerenciador - Template Matcher</title>
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- Font Awesome -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        .category-card, .template-card {
            transition: transform 0.2s ease;
        }
        .category-card:hover, .template-card:hover {
            transform: translateY(-2px);
        }
        .keywords-badge {
            font-size: 0.85em;
            margin-right: 0.5em;
            margin-bottom: 0.5em;
        }
        .loading-spinner {
            display: none;
        }
        .empty-message {
            padding: 2rem;
            text-align: center;
            color: #6c757d;
        }
        .action-buttons {
            opacity: 0;
            transition: opacity 0.2s ease;
        }
        .category-card:hover .action-buttons,
        .template-card:hover .action-buttons {
            opacity: 1;
        }
    </style>
</head>
<body>
    <!-- Navbar -->
    <nav class="navbar navbar-expand-lg navbar-dark bg-primary">
        <div class="container">
            <a class="navbar-brand" href="/">Template Matcher</a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav">
                    <li class="nav-item">
                        <a class="nav-link" href="/">Analisador</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link active" href="/manager">Gerenciador</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <!-- Main Content -->
    <div class="container my-4">
        <!-- Tabs -->
        <ul class="nav nav-tabs mb-4" id="managerTabs" role="tablist">
            <li class="nav-item" role="presentation">
                <button class="nav-link active" id="categories-tab" data-bs-toggle="tab" 
                        data-bs-target="#categories" type="button" role="tab">
                    <i class="fas fa-tags me-2"></i>
                    Categorias
                </button>
            </li>
            <li class="nav-item" role="presentation">
                <button class="nav-link" id="templates-tab" data-bs-toggle="tab" 
                        data-bs-target="#templates" type="button" role="tab">
                    <i class="fas fa-file-alt me-2"></i>
                    Templates
                </button>
            </li>
        </ul>

        <!-- Tab Content -->
        <div class="tab-content" id="managerTabsContent">
            <!-- Categories Tab -->
            <div class="tab-pane fade show active" id="categories" role="tabpanel">
                <div class="row">
                    <!-- Category Form -->
                    <div class="col-md-4">
                        <div class="card">
                            <div class="card-header bg-primary text-white">
                                <h5 class="mb-0">
                                    <i class="fas fa-plus-circle me-2"></i>
                                    Nova Categoria
                                </h5>
                            </div>
                            <div class="card-body">
                                <form id="categoryForm" onsubmit="handleCategorySubmit(event)">
                                    <div class="mb-3">
                                        <label class="form-label">Nome</label>
                                        <input type="text" class="form-control" name="name" required>
                                    </div>
                                    <div class="mb-3">
                                        <label class="form-label">Palavras-chave</label>
                                        <textarea class="form-control" name="keywords" rows="3" 
                                            placeholder="Separadas por vírgula" required></textarea>
                                    </div>
                                    <div class="mb-3">
                                        <label class="form-label">Peso</label>
                                        <input type="number" class="form-control" name="weight" 
                                            min="0.5" max="5" step="0.5" value="1" required>
                                        <div class="form-text">
                                            Valor entre 0.5 e 5, usado para ajustar a importância da categoria
                                        </div>
                                    </div>
                                    <button type="submit" class="btn btn-primary">
                                        <i class="fas fa-save me-2"></i>
                                        Salvar Categoria
                                        <div class="spinner-border spinner-border-sm loading-spinner" role="status">
                                            <span class="visually-hidden">Carregando...</span>
                                        </div>
                                    </button>
                                </form>
                            </div>
                        </div>
                    </div>

                    <!-- Categories List -->
                    <div class="col-md-8">
                        <div class="card">
                            <div class="card-header bg-primary text-white d-flex justify-content-between align-items-center">
                                <h5 class="mb-0">
                                    <i class="fas fa-list me-2"></i>
                                    Categorias Existentes
                                </h5>
                                <button class="btn btn-sm btn-outline-light" onclick="refreshCategories()">
                                    <i class="fas fa-sync-alt"></i>
                                </button>
                            </div>
                            <div class="card-body">
                                <div id="categoriesList" class="row g-3">
                                    <!-- Categories will be inserted here -->
                                </div>
                                <!-- Empty state message -->
                                <div id="emptyCategoriesMessage" class="empty-message" style="display: none;">
                                    <i class="fas fa-folder-open fa-3x mb-3"></i>
                                    <p>Nenhuma categoria cadastrada ainda.</p>
                                    <p class="text-muted">Comece adicionando uma nova categoria usando o formulário ao lado.</p>
                                </div>
                                <!-- Loading message -->
                                <div id="loadingCategoriesMessage" class="empty-message">
                                    <div class="spinner-border text-primary mb-3" role="status">
                                        <span class="visually-hidden">Carregando...</span>
                                    </div>
                                    <p>Carregando categorias...</p>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Templates Tab -->
            <div class="tab-pane fade" id="templates" role="tabpanel">
                <div class="row">
                    <!-- Template Form -->
                    <div class="col-md-5">
                        <div class="card">
                            <div class="card-header bg-primary text-white">
                                <h5 class="mb-0">
                                    <i class="fas fa-plus-circle me-2"></i>
                                    Novo Template
                                </h5>
                            </div>
                            <div class="card-body">
                                <form id="templateForm" onsubmit="handleTemplateSubmit(event)">
                                    <div class="mb-3">
                                        <label class="form-label">Categoria</label>
                                        <select class="form-select" name="categoryId" required>
                                            <option value="">Selecione uma categoria...</option>
                                            <!-- Categories will be dynamically loaded here -->
                                        </select>
                                    </div>
                                    <div class="mb-3">
                                        <label class="form-label">Texto do Template</label>
                                        <textarea class="form-control" name="text" rows="4" 
                                            placeholder="Digite o texto do template..." required></textarea>
                                        <div class="form-text">
                                            Escreva a mensagem que será sugerida quando esta categoria for identificada.
                                        </div>
                                    </div>
                                    <button type="submit" class="btn btn-primary">
                                        <i class="fas fa-save me-2"></i>
                                        Salvar Template
                                        <div class="spinner-border spinner-border-sm loading-spinner" role="status">
                                            <span class="visually-hidden">Carregando...</span>
                                        </div>
                                    </button>
                                </form>
                            </div>
                        </div>
                    </div>

                    <!-- Templates List -->
                    <div class="col-md-7">
                        <div class="card">
                            <div class="card-header bg-primary text-white d-flex justify-content-between align-items-center">
                                <h5 class="mb-0">
                                    <i class="fas fa-list me-2"></i>
                                    Templates Existentes
                                </h5>
                                <button class="btn btn-sm btn-outline-light" onclick="refreshTemplates()">
                                    <i class="fas fa-sync-alt"></i>
                                </button>
                            </div>
                            <div class="card-body">
                                <div id="templatesList" class="row g-3">
                                    <!-- Templates will be inserted here -->
                                </div>
                                <!-- Empty state message -->
                                <div id="emptyTemplatesMessage" class="empty-message" style="display: none;">
                                    <i class="fas fa-file-alt fa-3x mb-3"></i>
                                    <p>Nenhum template cadastrado ainda.</p>
                                    <p class="text-muted">Comece adicionando um novo template usando o formulário ao lado.</p>
                                </div>
                                <!-- Loading message -->
                                <div id="loadingTemplatesMessage" class="empty-message">
                                    <div class="spinner-border text-primary mb-3" role="status">
                                        <span class="visually-hidden">Carregando...</span>
                                    </div>
                                    <p>Carregando templates...</p>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Toast container for notifications -->
    <div class="toast-container position-fixed bottom-0 end-0 p-3"></div>

    <!-- Modal for editing templates and categories will be added later -->

    <!-- Scripts -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
<script>
    // Funções Utilitárias

// Exibir notificações toast
function showToast(title, message, type = 'info') {
    const toastContainer = document.querySelector('.toast-container');
    const toastHtml = `
        <div class="toast align-items-center text-white bg-${type} border-0" role="alert" aria-live="assertive" aria-atomic="true">
            <div class="d-flex">
                <div class="toast-body">
                    <strong>${title}</strong><br>
                    ${message}
                </div>
                <button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast"></button>
            </div>
        </div>
    `;
    
    toastContainer.insertAdjacentHTML('beforeend', toastHtml);
    const toast = toastContainer.lastElementChild;
    const bsToast = new bootstrap.Toast(toast, { autohide: true, delay: 3000 });
    
    toast.addEventListener('hidden.bs.toast', () => {
        toast.remove();
    });
    
    bsToast.show();
}

// Gerenciar estado de carregamento dos formulários
function setFormLoading(formId, loading) {
    const form = document.getElementById(formId);
    if (!form) return;

    const submitButton = form.querySelector('button[type="submit"]');
    const loadingSpinner = submitButton?.querySelector('.loading-spinner');
    const inputs = form.querySelectorAll('input, textarea, select, button');
    
    if (submitButton && loadingSpinner) {
        submitButton.disabled = loading;
        loadingSpinner.style.display = loading ? 'inline-block' : 'none';
    }
    
    inputs.forEach(input => {
        input.disabled = loading;
    });
}

// Gerenciar mensagens de estado vazio e carregamento
function toggleLoadingState(section, loading, empty = false) {
    const loadingMessage = document.getElementById(`loading${section}Message`);
    const emptyMessage = document.getElementById(`empty${section}Message`);
    const contentList = document.getElementById(`${section.toLowerCase()}List`);
    
    if (loadingMessage) {
        loadingMessage.style.display = loading ? 'block' : 'none';
    }
    
    if (emptyMessage) {
        emptyMessage.style.display = !loading && empty ? 'block' : 'none';
    }
    
    if (contentList) {
        contentList.style.display = !loading && !empty ? 'block' : 'none';
    }
}

// Limpar formulário
function resetForm(formId) {
    const form = document.getElementById(formId);
    if (form) {
        form.reset();
        
        // Restaurar valores padrão específicos
        const weightInput = form.querySelector('input[name="weight"]');
        if (weightInput) {
            weightInput.value = "1";
        }
    }
}

// Formatar data para exibição
function formatDate(dateString) {
    const options = { 
        day: '2-digit', 
        month: '2-digit', 
        year: 'numeric',
        hour: '2-digit',
        minute: '2-digit'
    };
    return new Date(dateString).toLocaleDateString('pt-BR', options);
}

// Confirmar ação
function confirmAction(message) {
    return new confirm(message);
}

// Manipular erros de requisição
async function handleRequestError(response) {
    if (!response.ok) {
        const contentType = response.headers.get('content-type');
        let error = 'Ocorreu um erro na operação';
        
        if (contentType && contentType.includes('application/json')) {
            const data = await response.json();
            error = data.error || data.message || error;
        }
        
        throw new Error(error);
    }
    return response.json();
}

// Estado global para cache de dados
const state = {
    categories: [],
    templates: [],
    setCategories(newCategories) {
        this.categories = newCategories;
        this.updateCategorySelects();
    },
    updateCategorySelects() {
        const selects = document.querySelectorAll('select[name="categoryId"]');
        selects.forEach(select => {
            const currentValue = select.value;
            select.innerHTML = `
                <option value="">Selecione uma categoria...</option>
                ${this.categories.map(category => `
                    <option value="${category.id}" ${category.id === currentValue ? 'selected' : ''}>
                        ${category.name}
                    </option>
                `).join('')}
            `;
        });
    }
};

// Funções de Gerenciamento de Categorias

// Carregar e exibir categorias
async function refreshCategories() {
    toggleLoadingState('Categories', true);
    
    try {
        const response = await fetch('/api/categories');
        const categories = await handleRequestError(response);
        
        state.setCategories(categories);
        displayCategories(categories);
        
        toggleLoadingState('Categories', false, categories.length === 0);
    } catch (error) {
        showToast('Erro', error.message, 'danger');
        toggleLoadingState('Categories', false, true);
    }
}

// Exibir lista de categorias
function displayCategories(categories) {
    const categoriesList = document.getElementById('categoriesList');
    
    if (!categories.length) {
        return toggleLoadingState('Categories', false, true);
    }

    const html = categories.map(category => `
        <div class="col-12">
            <div class="card category-card h-100">
                <div class="card-body">
                    <div class="d-flex justify-content-between align-items-start">
                        <div>
                            <h5 class="card-title">${category.name}</h5>
                            <h6 class="card-subtitle mb-2 text-muted">
                                Peso: ${category.weight}
                            </h6>
                        </div>
                        <div class="action-buttons">
                            <button class="btn btn-sm btn-outline-primary me-1" 
                                    onclick="editCategory('${category.id}')">
                                <i class="fas fa-edit"></i>
                            </button>
                            <button class="btn btn-sm btn-outline-danger" 
                                    onclick="deleteCategory('${category.id}')">
                                <i class="fas fa-trash"></i>
                            </button>
                        </div>
                    </div>
                    
                    <div class="mt-2">
                        ${category.keywords.map(keyword => `
                            <span class="badge bg-secondary keywords-badge">
                                ${keyword}
                            </span>
                        `).join('')}
                    </div>
                    
                    <div class="mt-3">
                        <small class="text-muted">
                            Criado em: ${formatDate(category.createdAt)}
                        </small>
                    </div>
                </div>
            </div>
        </div>
    `).join('');

    categoriesList.innerHTML = html;
}

// Criar nova categoria
async function handleCategorySubmit(event) {
    event.preventDefault();
    setFormLoading('categoryForm', true);

    const formData = new FormData(event.target);
    const categoryData = {
        name: formData.get('name').trim(),
        keywords: formData.get('keywords')
            .split(',')
            .map(k => k.trim())
            .filter(k => k.length > 0),
        weight: Number(formData.get('weight'))
    };

    try {
        const response = await fetch('/api/categories', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(categoryData)
        });

        await handleRequestError(response);
        
        showToast('Sucesso', 'Categoria criada com sucesso!', 'success');
        resetForm('categoryForm');
        refreshCategories();
    } catch (error) {
        showToast('Erro', error.message, 'danger');
    } finally {
        setFormLoading('categoryForm', false);
    }
}

// Editar categoria
async function editCategory(categoryId) {
    const category = state.categories.find(c => c.id === categoryId);
    if (!category) {
        showToast('Erro', 'Categoria não encontrada', 'danger');
        return;
    }

    // Preencher formulário com dados atuais
    const form = document.getElementById('categoryForm');
    form.querySelector('input[name="name"]').value = category.name;
    form.querySelector('textarea[name="keywords"]').value = category.keywords.join(', ');
    form.querySelector('input[name="weight"]').value = category.weight;

    // Modificar botão de submit
    const submitButton = form.querySelector('button[type="submit"]');
    const originalHtml = submitButton.innerHTML;
    submitButton.innerHTML = `
        <i class="fas fa-save me-2"></i>
        Atualizar Categoria
        <div class="spinner-border spinner-border-sm loading-spinner" role="status">
            <span class="visually-hidden">Carregando...</span>
        </div>
    `;

    // Modificar comportamento do formulário
    const originalSubmitHandler = form.onsubmit;
    form.onsubmit = async (event) => {
        event.preventDefault();
        setFormLoading('categoryForm', true);

        const formData = new FormData(form);
        const updateData = {
            name: formData.get('name').trim(),
            keywords: formData.get('keywords')
                .split(',')
                .map(k => k.trim())
                .filter(k => k.length > 0),
            weight: Number(formData.get('weight'))
        };

        try {
            const response = await fetch(`/api/categories/${categoryId}`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(updateData)
            });

            await handleRequestError(response);
            
            showToast('Sucesso', 'Categoria atualizada com sucesso!', 'success');
            resetForm('categoryForm');
            refreshCategories();

            // Restaurar formulário ao estado original
            submitButton.innerHTML = originalHtml;
            form.onsubmit = originalSubmitHandler;
        } catch (error) {
            showToast('Erro', error.message, 'danger');
        } finally {
            setFormLoading('categoryForm', false);
        }
    };

    // Scroll para o formulário
    form.scrollIntoView({ behavior: 'smooth' });
}

// Excluir categoria
async function deleteCategory(categoryId) {
    if (!await confirmAction('Tem certeza que deseja excluir esta categoria? Todos os templates associados também serão removidos.')) {
        return;
    }

    try {
        const response = await fetch(`/api/categories/${categoryId}`, {
            method: 'DELETE'
        });

        await handleRequestError(response);
        
        showToast('Sucesso', 'Categoria excluída com sucesso!', 'success');
        refreshCategories();
        refreshTemplates(); // Atualizar templates pois podem ter sido afetados
    } catch (error) {
        showToast('Erro', error.message, 'danger');
    }
}

// Funções de Gerenciamento de Templates

// Carregar e exibir templates
async function refreshTemplates() {
    toggleLoadingState('Templates', true);
    
    try {
        const response = await fetch('/api/templates');
        const templates = await handleRequestError(response);
        
        // Atualizar templates no estado global
        state.templates = templates;
        
        displayTemplates(templates);
        toggleLoadingState('Templates', false, templates.length === 0);
    } catch (error) {
        showToast('Erro', error.message, 'danger');
        toggleLoadingState('Templates', false, true);
    }
}

// Exibir lista de templates
function displayTemplates(templates) {
    const templatesList = document.getElementById('templatesList');
    
    if (!templates.length) {
        return toggleLoadingState('Templates', false, true);
    }

    const html = templates.map(template => {
        const category = state.categories.find(c => c.id === template.categoryId);
        return `
            <div class="col-12">
                <div class="card template-card h-100">
                    <div class="card-body">
                        <div class="d-flex justify-content-between align-items-start">
                            <div>
                                <span class="badge bg-primary mb-2">
                                    ${category ? category.name : 'Categoria não encontrada'}
                                </span>
                                <p class="card-text">${template.text}</p>
                            </div>
                            <div class="action-buttons">
                                <button class="btn btn-sm btn-outline-primary me-1" 
                                        onclick="editTemplate('${template.id}')">
                                    <i class="fas fa-edit"></i>
                                </button>
                                <button class="btn btn-sm btn-outline-danger" 
                                        onclick="deleteTemplate('${template.id}')">
                                    <i class="fas fa-trash"></i>
                                </button>
                            </div>
                        </div>
                        <div class="mt-2">
                            <small class="text-muted">
                                Criado em: ${formatDate(template.createdAt)}
                            </small>
                        </div>
                    </div>
                </div>
            </div>
        `;
    }).join('');

    templatesList.innerHTML = html;
}

// Criar novo template
async function handleTemplateSubmit(event) {
    event.preventDefault();
    setFormLoading('templateForm', true);

    const formData = new FormData(event.target);
    const templateData = {
        categoryId: formData.get('categoryId'),
        text: formData.get('text').trim()
    };

    try {
        const response = await fetch('/api/templates', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(templateData)
        });

        await handleRequestError(response);
        
        showToast('Sucesso', 'Template criado com sucesso!', 'success');
        resetForm('templateForm');
        refreshTemplates();
    } catch (error) {
        showToast('Erro', error.message, 'danger');
    } finally {
        setFormLoading('templateForm', false);
    }
}

// Editar template
async function editTemplate(templateId) {
    const template = state.templates.find(t => t.id === templateId);
    if (!template) {
        showToast('Erro', 'Template não encontrado', 'danger');
        return;
    }

    // Preencher formulário com dados atuais
    const form = document.getElementById('templateForm');
    form.querySelector('select[name="categoryId"]').value = template.categoryId;
    form.querySelector('textarea[name="text"]').value = template.text;

    // Modificar botão de submit
    const submitButton = form.querySelector('button[type="submit"]');
    const originalHtml = submitButton.innerHTML;
    submitButton.innerHTML = `
        <i class="fas fa-save me-2"></i>
        Atualizar Template
        <div class="spinner-border spinner-border-sm loading-spinner" role="status">
            <span class="visually-hidden">Carregando...</span>
        </div>
    `;

    // Modificar comportamento do formulário
    const originalSubmitHandler = form.onsubmit;
    form.onsubmit = async (event) => {
        event.preventDefault();
        setFormLoading('templateForm', true);

        const formData = new FormData(form);
        const updateData = {
            categoryId: formData.get('categoryId'),
            text: formData.get('text').trim()
        };

        try {
            const response = await fetch(`/api/templates/${templateId}`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(updateData)
            });

            await handleRequestError(response);
            
            showToast('Sucesso', 'Template atualizado com sucesso!', 'success');
            resetForm('templateForm');
            refreshTemplates();

            // Restaurar formulário ao estado original
            submitButton.innerHTML = originalHtml;
            form.onsubmit = originalSubmitHandler;
        } catch (error) {
            showToast('Erro', error.message, 'danger');
        } finally {
            setFormLoading('templateForm', false);
        }
    };

    // Scroll para o formulário
    form.scrollIntoView({ behavior: 'smooth' });
}

// Excluir template
async function deleteTemplate(templateId) {
    if (!await confirmAction('Tem certeza que deseja excluir este template?')) {
        return;
    }

    try {
        const response = await fetch(`/api/templates/${templateId}`, {
            method: 'DELETE'
        });

        await handleRequestError(response);
        
        showToast('Sucesso', 'Template excluído com sucesso!', 'success');
        refreshTemplates();
    } catch (error) {
        showToast('Erro', error.message, 'danger');
    }
}

// Inicialização da página
document.addEventListener('DOMContentLoaded', () => {
    // Carregar dados iniciais
    refreshCategories();
    refreshTemplates();

    // Configurar atualização automática dos dados
    const tabs = document.querySelectorAll('button[data-bs-toggle="tab"]');
    tabs.forEach(tab => {
        tab.addEventListener('shown.bs.tab', (event) => {
            if (event.target.getAttribute('data-bs-target') === '#categories') {
                refreshCategories();
            } else if (event.target.getAttribute('data-bs-target') === '#templates') {
                refreshTemplates();
            }
        });
    });

    // Interceptar resets de formulário para limpar corretamente
    const forms = document.querySelectorAll('form');
    forms.forEach(form => {
        form.addEventListener('reset', () => {
            setTimeout(() => {
                const weightInput = form.querySelector('input[name="weight"]');
                if (weightInput) {
                    weightInput.value = "1";
                }
            }, 0);
        });
    });
});

// Handler para tecla Escape
document.addEventListener('keydown', (event) => {
    if (event.key === 'Escape') {
        // Resetar formulários se estiverem em modo de edição
        const categoryForm = document.getElementById('categoryForm');
        const templateForm = document.getElementById('templateForm');

        if (categoryForm.querySelector('button[type="submit"]').textContent.includes('Atualizar')) {
            categoryForm.reset();
            categoryForm.onsubmit = handleCategorySubmit;
            categoryForm.querySelector('button[type="submit"]').innerHTML = `
                <i class="fas fa-save me-2"></i>
                Salvar Categoria
                <div class="spinner-border spinner-border-sm loading-spinner" role="status">
                    <span class="visually-hidden">Carregando...</span>
                </div>
            `;
        }

        if (templateForm.querySelector('button[type="submit"]').textContent.includes('Atualizar')) {
            templateForm.reset();
            templateForm.onsubmit = handleTemplateSubmit;
            templateForm.querySelector('button[type="submit"]').innerHTML = `
                <i class="fas fa-save me-2"></i>
                Salvar Template
                <div class="spinner-border spinner-border-sm loading-spinner" role="status">
                    <span class="visually-hidden">Carregando...</span>
                </div>
            `;
        }
    }
});

</script>
</body>
</html>

================
File: src/routes/categoryRoutes.ts
================
// src/routes/categoryRoutes.ts

import express from 'express';
import categoryController from '../controllers/categoryController';

const router = express.Router();

// Rotas básicas CRUD
router.get('/', categoryController.getAllCategories);
router.get('/:id', categoryController.getCategory);
router.post('/', categoryController.createCategory);
router.put('/:id', categoryController.updateCategory);
router.delete('/:id', categoryController.deleteCategory);

export default router;

================
File: src/routes/templateRoutes.ts
================
// src/routes/templateRoutes.ts

import express from 'express';
import templateController from '../controllers/templateController';

const router = express.Router();

router.get('/', templateController.getAllTemplates);
router.get('/:id', templateController.getTemplate);
router.post('/', templateController.createTemplate);
router.put('/:id', templateController.updateTemplate);
router.delete('/:id', templateController.deleteTemplate);

export default router;

================
File: src/services/messageAnalyzer.ts
================
// src/services/storageService.ts

import { Category, Template, CreateCategoryDTO, CreateTemplateDTO, UpdateCategoryDTO, UpdateTemplateDTO } from '../models/types';
import fs from 'fs';
import path from 'path';

class StorageService {
    private static instance: StorageService;
    private categories: Category[] = [];
    private templates: Template[] = [];
    private readonly dataDir = path.join(__dirname, '../../data');
    private readonly categoriesFile = path.join(this.dataDir, 'categories.json');
    private readonly templatesFile = path.join(this.dataDir, 'templates.json');

    private constructor() {
        this.initializeStorage();
    }

    public static getInstance(): StorageService {
        if (!StorageService.instance) {
            StorageService.instance = new StorageService();
        }
        return StorageService.instance;
    }

    private initializeStorage() {
        if (!fs.existsSync(this.dataDir)) {
            fs.mkdirSync(this.dataDir, { recursive: true });
        }

        try {
            if (fs.existsSync(this.categoriesFile)) {
                const data = fs.readFileSync(this.categoriesFile, 'utf8');
                this.categories = JSON.parse(data);
            }

            if (fs.existsSync(this.templatesFile)) {
                const data = fs.readFileSync(this.templatesFile, 'utf8');
                this.templates = JSON.parse(data);
            }
        } catch (error) {
            console.error('Erro ao carregar dados:', error);
            // Inicializar com arrays vazios em caso de erro
            this.categories = [];
            this.templates = [];
        }
    }

    private saveCategories(): void {
        fs.writeFileSync(this.categoriesFile, JSON.stringify(this.categories, null, 2));
    }

    private saveTemplates(): void {
        fs.writeFileSync(this.templatesFile, JSON.stringify(this.templates, null, 2));
    }

    // Métodos para Categorias
    async getCategories(): Promise<Category[]> {
        return this.categories;
    }

    async getCategory(id: string): Promise<Category | null> {
        return this.categories.find(c => c.id === id) || null;
    }

    async createCategory(data: CreateCategoryDTO): Promise<Category> {
        const newCategory: Category = {
            ...data,
            id: crypto.randomUUID(),
            createdAt: new Date(),
            updatedAt: new Date()
        };

        this.categories.push(newCategory);
        this.saveCategories();
        return newCategory;
    }

    async updateCategory(id: string, data: UpdateCategoryDTO): Promise<Category | null> {
        const index = this.categories.findIndex(c => c.id === id);
        if (index === -1) return null;

        const updatedCategory = {
            ...this.categories[index],
            ...data,
            updatedAt: new Date()
        };

        this.categories[index] = updatedCategory;
        this.saveCategories();
        return updatedCategory;
    }

    async deleteCategory(id: string): Promise<boolean> {
        const initialLength = this.categories.length;
        this.categories = this.categories.filter(c => c.id !== id);
        
        if (this.categories.length < initialLength) {
            // Excluir templates associados à categoria
            this.templates = this.templates.filter(t => t.categoryId !== id);
            this.saveCategories();
            this.saveTemplates();
            return true;
        }
        return false;
    }

    // Métodos para Templates
    async getTemplates(): Promise<Template[]> {
        return this.templates;
    }

    async getTemplate(id: string): Promise<Template | null> {
        return this.templates.find(t => t.id === id) || null;
    }

    async getTemplatesByCategory(categoryId: string): Promise<Template[]> {
        return this.templates.filter(t => t.categoryId === categoryId);
    }

    async createTemplate(data: CreateTemplateDTO): Promise<Template> {
        // Verificar se a categoria existe
        const categoryExists = this.categories.some(c => c.id === data.categoryId);
        if (!categoryExists) {
            throw new Error('Categoria não encontrada');
        }

        const newTemplate: Template = {
            ...data,
            id: crypto.randomUUID(),
            createdAt: new Date(),
            updatedAt: new Date()
        };

        this.templates.push(newTemplate);
        this.saveTemplates();
        return newTemplate;
    }

    async updateTemplate(id: string, data: UpdateTemplateDTO): Promise<Template | null> {
        const index = this.templates.findIndex(t => t.id === id);
        if (index === -1) return null;

        // Se estiver atualizando a categoria, verificar se a nova categoria existe
        if (data.categoryId) {
            const categoryExists = this.categories.some(c => c.id === data.categoryId);
            if (!categoryExists) {
                throw new Error('Categoria não encontrada');
            }
        }

        const updatedTemplate = {
            ...this.templates[index],
            ...data,
            updatedAt: new Date()
        };

        this.templates[index] = updatedTemplate;
        this.saveTemplates();
        return updatedTemplate;
    }

    async deleteTemplate(id: string): Promise<boolean> {
        const initialLength = this.templates.length;
        this.templates = this.templates.filter(t => t.id !== id);
        
        if (this.templates.length < initialLength) {
            this.saveTemplates();
            return true;
        }
        return false;
    }

    // Método para resetar o armazenamento (útil para testes)
    async resetStorage(): Promise<void> {
        this.categories = [];
        this.templates = [];
        this.saveCategories();
        this.saveTemplates();
    }
}

export default StorageService.getInstance();

================
File: src/services/storageService.ts
================
// src/services/storageService.ts

import { Category, Template, CreateCategoryDTO, CreateTemplateDTO, UpdateCategoryDTO, UpdateTemplateDTO } from '../models/types';
import fs from 'fs';
import path from 'path';

class StorageService {
    private static instance: StorageService;
    private categories: Category[] = [];
    private templates: Template[] = [];
    private readonly dataDir = path.join(__dirname, '../../data');
    private readonly categoriesFile = path.join(this.dataDir, 'categories.json');
    private readonly templatesFile = path.join(this.dataDir, 'templates.json');

    private constructor() {
        this.initializeStorage();
    }

    public static getInstance(): StorageService {
        if (!StorageService.instance) {
            StorageService.instance = new StorageService();
        }
        return StorageService.instance;
    }

    private initializeStorage() {
        if (!fs.existsSync(this.dataDir)) {
            fs.mkdirSync(this.dataDir, { recursive: true });
        }

        try {
            if (fs.existsSync(this.categoriesFile)) {
                const data = fs.readFileSync(this.categoriesFile, 'utf8');
                this.categories = JSON.parse(data);
            }

            if (fs.existsSync(this.templatesFile)) {
                const data = fs.readFileSync(this.templatesFile, 'utf8');
                this.templates = JSON.parse(data);
            }
        } catch (error) {
            console.error('Erro ao carregar dados:', error);
            // Inicializar com arrays vazios em caso de erro
            this.categories = [];
            this.templates = [];
        }
    }

    private saveCategories(): void {
        fs.writeFileSync(this.categoriesFile, JSON.stringify(this.categories, null, 2));
    }

    private saveTemplates(): void {
        fs.writeFileSync(this.templatesFile, JSON.stringify(this.templates, null, 2));
    }

    // Métodos para Categorias
    async getCategories(): Promise<Category[]> {
        return this.categories;
    }

    async getCategory(id: string): Promise<Category | null> {
        return this.categories.find(c => c.id === id) || null;
    }

    async createCategory(data: CreateCategoryDTO): Promise<Category> {
        const newCategory: Category = {
            ...data,
            id: crypto.randomUUID(),
            createdAt: new Date(),
            updatedAt: new Date()
        };

        this.categories.push(newCategory);
        this.saveCategories();
        return newCategory;
    }

    async updateCategory(id: string, data: UpdateCategoryDTO): Promise<Category | null> {
        const index = this.categories.findIndex(c => c.id === id);
        if (index === -1) return null;

        const updatedCategory = {
            ...this.categories[index],
            ...data,
            updatedAt: new Date()
        };

        this.categories[index] = updatedCategory;
        this.saveCategories();
        return updatedCategory;
    }

    async deleteCategory(id: string): Promise<boolean> {
        const initialLength = this.categories.length;
        this.categories = this.categories.filter(c => c.id !== id);
        
        if (this.categories.length < initialLength) {
            // Excluir templates associados à categoria
            this.templates = this.templates.filter(t => t.categoryId !== id);
            this.saveCategories();
            this.saveTemplates();
            return true;
        }
        return false;
    }

    // Métodos para Templates
    async getTemplates(): Promise<Template[]> {
        return this.templates;
    }

    async getTemplate(id: string): Promise<Template | null> {
        return this.templates.find(t => t.id === id) || null;
    }

    async getTemplatesByCategory(categoryId: string): Promise<Template[]> {
        return this.templates.filter(t => t.categoryId === categoryId);
    }

    async createTemplate(data: CreateTemplateDTO): Promise<Template> {
        // Verificar se a categoria existe
        const categoryExists = this.categories.some(c => c.id === data.categoryId);
        if (!categoryExists) {
            throw new Error('Categoria não encontrada');
        }

        const newTemplate: Template = {
            ...data,
            id: crypto.randomUUID(),
            createdAt: new Date(),
            updatedAt: new Date()
        };

        this.templates.push(newTemplate);
        this.saveTemplates();
        return newTemplate;
    }

    async updateTemplate(id: string, data: UpdateTemplateDTO): Promise<Template | null> {
        const index = this.templates.findIndex(t => t.id === id);
        if (index === -1) return null;

        // Se estiver atualizando a categoria, verificar se a nova categoria existe
        if (data.categoryId) {
            const categoryExists = this.categories.some(c => c.id === data.categoryId);
            if (!categoryExists) {
                throw new Error('Categoria não encontrada');
            }
        }

        const updatedTemplate = {
            ...this.templates[index],
            ...data,
            updatedAt: new Date()
        };

        this.templates[index] = updatedTemplate;
        this.saveTemplates();
        return updatedTemplate;
    }

    async deleteTemplate(id: string): Promise<boolean> {
        const initialLength = this.templates.length;
        this.templates = this.templates.filter(t => t.id !== id);
        
        if (this.templates.length < initialLength) {
            this.saveTemplates();
            return true;
        }
        return false;
    }

    // Método para resetar o armazenamento (útil para testes)
    async resetStorage(): Promise<void> {
        this.categories = [];
        this.templates = [];
        this.saveCategories();
        this.saveTemplates();
    }
}

export default StorageService.getInstance();

================
File: src/utils/keywords.ts
================
// src/utils/keywords.ts

export interface KeywordCategory {
    category: string;
    keywords: string[];
    weight: number;
}

export const keywordCategories: KeywordCategory[] = [
    {
        category: 'preço',
        keywords: [
            'valor', 'preço', 'custo', 'caro', 'barato', 
            'desconto', 'promoção', 'pagamento', 'parcelas',
            'orçamento', 'investimento', 'financeiro'
        ],
        weight: 1
    },
    {
        category: 'urgência',
        keywords: [
            'urgente', 'emergência', 'dor', 'agora', 
            'imediato', 'hoje', 'rápido', 'socorro',
            'grave', 'urgência', 'quando'
        ],
        weight: 2 // Urgência tem peso maior
    },
    {
        category: 'informação',
        keywords: [
            'dúvida', 'como', 'informação', 'funciona', 
            'explicar', 'saber', 'conhecer', 'procedimento',
            'tratamento', 'consulta'
        ],
        weight: 1
    },
    {
        category: 'saudação',
        keywords: [
            'olá', 'oi', 'bom dia', 'boa tarde', 
            'boa noite', 'hi', 'hello'
        ],
        weight: 0.5 // Saudações tem peso menor
    }
];

export const defaultTemplates = {
    preço: [
        "Entendo sua preocupação com os valores. Nossa clínica oferece diversas opções de pagamento e parcelamento. Podemos agendar uma avaliação gratuita para discutir o melhor plano para você?",
        "Trabalhamos com preços competitivos e várias formas de pagamento. Que tal agendarmos uma avaliação sem compromisso para discutirmos as melhores opções para seu caso?"
    ],
    urgência: [
        "Compreendo a urgência da sua situação. Temos horários disponíveis para emergências. Poderia me dizer mais sobre o que está sentindo?",
        "Nossa clínica está preparada para atendimentos de urgência. Vou priorizar seu caso. Pode me dar mais detalhes sobre o que está acontecendo?"
    ],
    informação: [
        "Claro! Ficarei feliz em esclarecer suas dúvidas sobre nossos tratamentos. Qual procedimento específico você gostaria de conhecer melhor?",
        "Posso te explicar detalhadamente sobre nossos procedimentos. Qual aspecto específico você gostaria de entender melhor?"
    ],
    saudação: [
        "Olá! Seja bem-vindo(a) à [Nome da Clínica]. Como posso ajudar você hoje?",
        "Olá! Que bom ter você por aqui. Em que posso ser útil?"
    ]
};

================
File: tsconfig.json
================
{
  "compilerOptions": {
    "target": "es6",
    "module": "commonjs",
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules"]
}
